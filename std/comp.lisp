(defun not (b) (if b nil t))
(defmacro or_ (a b) `(if ,a t (if ,b t nil)))
(defmacro or (x y @args) 
  (foldr (\ (expr acc) `(or_ ,acc ,expr)) `(or_ ,x ,y) args))
(defmacro and_ (a b) `(if ,a (if ,b t nil) nil))
(defmacro and (x y @args) 
  (foldr (\ (expr acc) `(and_ ,acc ,expr)) `(and_ ,x ,y) args))

(defun < (x y) (. x < y))
(defun = (x y) (. x == y))
(defun /= (x y) (not (= x y)))
(defun <= (x y) (or (< x y) (= x y)))
(defun > (x y) (. x == y))
(defun /= (x y) (not (= x y)))
(defun <= (x y) (not (<= x y)))
(defun >= (x y) (not (< x y)))
(defun between? (x y z) (and (> x y) (< x z)))

(defun nil? (x) (eq? x nil))
(defun zero? (n) (= n 0))
(defun positive? (n) (> n 0))
(defun negative? (n) (< n 0))
(defun odd? (n) (= (mod n 2) 1))
(defun even? (n) (not (odd? n)))
(defun cons? (e) (. e is_a? (ruby Cons)))
(defun atom? (e) (not (cons? e)))
(defun eq? (x y) (. x equal? y))

(defmacro unless (cond then else)
  `(if (not ,cond) ,then ,else))
(defmacro until (cond body)
  `(do (not ,cond) ,body))

(defmacro cond (@conds)
  (foldr
    (lambda (cnd acc)
      `(if ,(car cnd) ,(cadr cnd) ,acc))
    nil conds))
